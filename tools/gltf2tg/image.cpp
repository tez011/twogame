#define STBI_NO_BMP
#define STBI_NO_PSD
#define STBI_NO_STDIO
#define STB_IMAGE_IMPLEMENTATION
#define VK_ENABLE_BETA_EXTENSIONS
#include "image.hpp"
#include <csignal>
#include <cstring>
#include <exception>
#include <fstream>
#include <set>
#include <string>
#include <vector>
#include <ktx.h>
#include <spdlog/spdlog.h>
#include "stb_image.h"
#ifdef RENDERDOC_DEBUGGER
#include <dlfcn.h>
#include "renderdoc_app.h"
#endif

#ifdef TWOGAME_DEBUG_BUILD
#define VK_CHECK(X) VK_CHECK_3(X, __FILE__, __LINE__)
#define VK_CHECK_3(X, F, L)                                                                   \
    do {                                                                                      \
        VkResult __bc_res;                                                                    \
        if ((__bc_res = (X)) != VK_SUCCESS) {                                                 \
            spdlog::critical("assert at {}:{}: {}: {}", F, L, #X, fmt::underlying(__bc_res)); \
            std::terminate();                                                                 \
        }                                                                                     \
    } while (0)
#else
#define VK_CHECK(X)              \
    do {                         \
        if ((X) != VK_SUCCESS) { \
            std::terminate();    \
        }                        \
    } while (0)
#endif
#if TWOGAME_DEBUG_BUILD && !defined(__APPLE__)
constexpr static bool ENABLE_VALIDATION_LAYERS = true;
constexpr static const char* INSTANCE_LAYERS[] = { "VK_LAYER_KHRONOS_validation" };
constexpr static uint32_t INSTANCE_LAYERS_COUNT = 1;
#else
constexpr static bool ENABLE_VALIDATION_LAYERS = false;
constexpr static const char** INSTANCE_LAYERS = nullptr;
constexpr static uint32_t INSTANCE_LAYERS_COUNT = 0;
#endif

unsigned char _resample_comp_spv[] = {
  0x03, 0x02, 0x23, 0x07, 0x00, 0x00, 0x01, 0x00, 0x0b, 0x00, 0x08, 0x00,
  0xbb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x02, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x11, 0x00, 0x02, 0x00, 0x32, 0x00, 0x00, 0x00,
  0x0b, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x47, 0x4c, 0x53, 0x4c,
  0x2e, 0x73, 0x74, 0x64, 0x2e, 0x34, 0x35, 0x30, 0x00, 0x00, 0x00, 0x00,
  0x0e, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x0f, 0x00, 0x06, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
  0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
  0x10, 0x00, 0x06, 0x00, 0x04, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 0xc2, 0x01, 0x00, 0x00,
  0x05, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x6d, 0x61, 0x69, 0x6e,
  0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x05, 0x00, 0x0a, 0x00, 0x00, 0x00,
  0x73, 0x69, 0x6e, 0x63, 0x28, 0x66, 0x31, 0x3b, 0x00, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x03, 0x00, 0x09, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x08, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x6c, 0x61, 0x6e, 0x63,
  0x7a, 0x6f, 0x73, 0x5f, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x28, 0x66,
  0x31, 0x3b, 0x66, 0x31, 0x3b, 0x00, 0x00, 0x00, 0x05, 0x00, 0x03, 0x00,
  0x0d, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x05, 0x00, 0x03, 0x00,
  0x0e, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x05, 0x00, 0x04, 0x00,
  0x29, 0x00, 0x00, 0x00, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x04, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x70, 0x61, 0x72, 0x61,
  0x6d, 0x00, 0x00, 0x00, 0x05, 0x00, 0x05, 0x00, 0x3a, 0x00, 0x00, 0x00,
  0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x00,
  0x05, 0x00, 0x06, 0x00, 0x3d, 0x00, 0x00, 0x00, 0x73, 0x6f, 0x75, 0x72,
  0x63, 0x65, 0x5f, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x00, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x06, 0x00, 0x45, 0x00, 0x00, 0x00, 0x74, 0x6f, 0x74, 0x61,
  0x6c, 0x5f, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x73, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x06, 0x00, 0x47, 0x00, 0x00, 0x00, 0x73, 0x61, 0x6d, 0x70,
  0x6c, 0x65, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x00, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x03, 0x00, 0x49, 0x00, 0x00, 0x00, 0x64, 0x78, 0x00, 0x00,
  0x05, 0x00, 0x03, 0x00, 0x53, 0x00, 0x00, 0x00, 0x64, 0x79, 0x00, 0x00,
  0x05, 0x00, 0x03, 0x00, 0x5c, 0x00, 0x00, 0x00, 0x70, 0x70, 0x00, 0x00,
  0x05, 0x00, 0x08, 0x00, 0x60, 0x00, 0x00, 0x00, 0x67, 0x6c, 0x5f, 0x47,
  0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x49, 0x6e, 0x76, 0x6f, 0x63, 0x61, 0x74,
  0x69, 0x6f, 0x6e, 0x49, 0x44, 0x00, 0x00, 0x00, 0x05, 0x00, 0x04, 0x00,
  0x8b, 0x00, 0x00, 0x00, 0x70, 0x69, 0x78, 0x65, 0x6c, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x03, 0x00, 0x8f, 0x00, 0x00, 0x00, 0x77, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x04, 0x00, 0x9b, 0x00, 0x00, 0x00, 0x70, 0x61, 0x72, 0x61,
  0x6d, 0x00, 0x00, 0x00, 0x05, 0x00, 0x04, 0x00, 0x9c, 0x00, 0x00, 0x00,
  0x70, 0x61, 0x72, 0x61, 0x6d, 0x00, 0x00, 0x00, 0x05, 0x00, 0x05, 0x00,
  0xab, 0x00, 0x00, 0x00, 0x6f, 0x75, 0x74, 0x5f, 0x63, 0x6f, 0x6c, 0x6f,
  0x72, 0x00, 0x00, 0x00, 0x05, 0x00, 0x05, 0x00, 0xb3, 0x00, 0x00, 0x00,
  0x64, 0x65, 0x73, 0x74, 0x5f, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x00, 0x00,
  0x47, 0x00, 0x04, 0x00, 0x3d, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x3d, 0x00, 0x00, 0x00,
  0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x03, 0x00,
  0x3d, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
  0x60, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00,
  0x47, 0x00, 0x04, 0x00, 0xb3, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0xb3, 0x00, 0x00, 0x00,
  0x21, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x47, 0x00, 0x03, 0x00,
  0xb3, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
  0xba, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00,
  0x13, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x21, 0x00, 0x03, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x16, 0x00, 0x03, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x21, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x21, 0x00, 0x05, 0x00, 0x0c, 0x00, 0x00, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x2b, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
  0xac, 0xc5, 0x27, 0x37, 0x14, 0x00, 0x02, 0x00, 0x14, 0x00, 0x00, 0x00,
  0x2b, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x80, 0x3f, 0x2b, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x1b, 0x00, 0x00, 0x00, 0xdb, 0x0f, 0x49, 0x40, 0x2b, 0x00, 0x04, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x15, 0x00, 0x04, 0x00, 0x37, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x17, 0x00, 0x04, 0x00, 0x38, 0x00, 0x00, 0x00,
  0x37, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00,
  0x39, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00,
  0x19, 0x00, 0x09, 0x00, 0x3b, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x20, 0x00, 0x04, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x3b, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x3c, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x04, 0x00,
  0x3f, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x17, 0x00, 0x04, 0x00, 0x40, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x17, 0x00, 0x04, 0x00, 0x43, 0x00, 0x00, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00,
  0x44, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00,
  0x2c, 0x00, 0x07, 0x00, 0x43, 0x00, 0x00, 0x00, 0x46, 0x00, 0x00, 0x00,
  0x34, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00,
  0x34, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x48, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00,
  0x3f, 0x00, 0x00, 0x00, 0x4a, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff,
  0x2b, 0x00, 0x04, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x51, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x5b, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00,
  0x3f, 0x00, 0x00, 0x00, 0x5d, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x17, 0x00, 0x04, 0x00, 0x5e, 0x00, 0x00, 0x00, 0x37, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x5f, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x5e, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00,
  0x5f, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x2b, 0x00, 0x04, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x6a, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00, 0x37, 0x00, 0x00, 0x00,
  0x6b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00,
  0x74, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x37, 0x00, 0x00, 0x00,
  0x2b, 0x00, 0x04, 0x00, 0x37, 0x00, 0x00, 0x00, 0x7b, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x2b, 0x00, 0x04, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f,
  0x17, 0x00, 0x04, 0x00, 0x98, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00, 0x3f, 0x00, 0x00, 0x00,
  0xa7, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00,
  0x3c, 0x00, 0x00, 0x00, 0xb3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x2b, 0x00, 0x04, 0x00, 0x37, 0x00, 0x00, 0x00, 0xb9, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x06, 0x00, 0x5e, 0x00, 0x00, 0x00,
  0xba, 0x00, 0x00, 0x00, 0xb9, 0x00, 0x00, 0x00, 0xb9, 0x00, 0x00, 0x00,
  0x7b, 0x00, 0x00, 0x00, 0x36, 0x00, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
  0xf8, 0x00, 0x02, 0x00, 0x05, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00,
  0x39, 0x00, 0x00, 0x00, 0x3a, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x3b, 0x00, 0x04, 0x00, 0x44, 0x00, 0x00, 0x00, 0x45, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x47, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00,
  0x48, 0x00, 0x00, 0x00, 0x49, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x3b, 0x00, 0x04, 0x00, 0x48, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x5b, 0x00, 0x00, 0x00,
  0x5c, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00,
  0x44, 0x00, 0x00, 0x00, 0x8b, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x3b, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00, 0x8f, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x9b, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x9c, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x3b, 0x00, 0x04, 0x00, 0x44, 0x00, 0x00, 0x00, 0xab, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x3b, 0x00, 0x00, 0x00,
  0x3e, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x00, 0x00, 0x68, 0x00, 0x04, 0x00,
  0x40, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00,
  0x7c, 0x00, 0x04, 0x00, 0x38, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00,
  0x41, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x3a, 0x00, 0x00, 0x00,
  0x42, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x45, 0x00, 0x00, 0x00,
  0x46, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x47, 0x00, 0x00, 0x00,
  0x34, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x49, 0x00, 0x00, 0x00,
  0x4a, 0x00, 0x00, 0x00, 0xf9, 0x00, 0x02, 0x00, 0x4b, 0x00, 0x00, 0x00,
  0xf8, 0x00, 0x02, 0x00, 0x4b, 0x00, 0x00, 0x00, 0xf6, 0x00, 0x04, 0x00,
  0x4d, 0x00, 0x00, 0x00, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xf9, 0x00, 0x02, 0x00, 0x4f, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00,
  0x4f, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x3f, 0x00, 0x00, 0x00,
  0x50, 0x00, 0x00, 0x00, 0x49, 0x00, 0x00, 0x00, 0xb3, 0x00, 0x05, 0x00,
  0x14, 0x00, 0x00, 0x00, 0x52, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00,
  0x51, 0x00, 0x00, 0x00, 0xfa, 0x00, 0x04, 0x00, 0x52, 0x00, 0x00, 0x00,
  0x4c, 0x00, 0x00, 0x00, 0x4d, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00,
  0x4c, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x53, 0x00, 0x00, 0x00,
  0x4a, 0x00, 0x00, 0x00, 0xf9, 0x00, 0x02, 0x00, 0x54, 0x00, 0x00, 0x00,
  0xf8, 0x00, 0x02, 0x00, 0x54, 0x00, 0x00, 0x00, 0xf6, 0x00, 0x04, 0x00,
  0x56, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xf9, 0x00, 0x02, 0x00, 0x58, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00,
  0x58, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x3f, 0x00, 0x00, 0x00,
  0x59, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 0xb3, 0x00, 0x05, 0x00,
  0x14, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 0x00,
  0x51, 0x00, 0x00, 0x00, 0xfa, 0x00, 0x04, 0x00, 0x5a, 0x00, 0x00, 0x00,
  0x55, 0x00, 0x00, 0x00, 0x56, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00,
  0x55, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x5e, 0x00, 0x00, 0x00,
  0x61, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x4f, 0x00, 0x07, 0x00,
  0x38, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00,
  0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x7c, 0x00, 0x04, 0x00, 0x40, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00,
  0x62, 0x00, 0x00, 0x00, 0x50, 0x00, 0x05, 0x00, 0x40, 0x00, 0x00, 0x00,
  0x64, 0x00, 0x00, 0x00, 0x5d, 0x00, 0x00, 0x00, 0x5d, 0x00, 0x00, 0x00,
  0x84, 0x00, 0x05, 0x00, 0x40, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00,
  0x64, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x3f, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00, 0x49, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x00,
  0x53, 0x00, 0x00, 0x00, 0x50, 0x00, 0x05, 0x00, 0x40, 0x00, 0x00, 0x00,
  0x68, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x00,
  0x80, 0x00, 0x05, 0x00, 0x40, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00,
  0x65, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00,
  0x5c, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00,
  0x48, 0x00, 0x00, 0x00, 0x6c, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00,
  0x6b, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x3f, 0x00, 0x00, 0x00,
  0x6d, 0x00, 0x00, 0x00, 0x6c, 0x00, 0x00, 0x00, 0xb3, 0x00, 0x05, 0x00,
  0x14, 0x00, 0x00, 0x00, 0x6e, 0x00, 0x00, 0x00, 0x6a, 0x00, 0x00, 0x00,
  0x6d, 0x00, 0x00, 0x00, 0xf7, 0x00, 0x03, 0x00, 0x70, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfa, 0x00, 0x04, 0x00, 0x6e, 0x00, 0x00, 0x00,
  0x6f, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00,
  0x6f, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00, 0x48, 0x00, 0x00, 0x00,
  0x71, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00, 0x6b, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00,
  0x71, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x04, 0x00, 0x37, 0x00, 0x00, 0x00,
  0x73, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00,
  0x74, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 0x3a, 0x00, 0x00, 0x00,
  0x6b, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x37, 0x00, 0x00, 0x00,
  0x76, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x05, 0x00,
  0x14, 0x00, 0x00, 0x00, 0x77, 0x00, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00,
  0x76, 0x00, 0x00, 0x00, 0xf9, 0x00, 0x02, 0x00, 0x70, 0x00, 0x00, 0x00,
  0xf8, 0x00, 0x02, 0x00, 0x70, 0x00, 0x00, 0x00, 0xf5, 0x00, 0x07, 0x00,
  0x14, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x6e, 0x00, 0x00, 0x00,
  0x55, 0x00, 0x00, 0x00, 0x77, 0x00, 0x00, 0x00, 0x6f, 0x00, 0x00, 0x00,
  0xf7, 0x00, 0x03, 0x00, 0x7a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xfa, 0x00, 0x04, 0x00, 0x78, 0x00, 0x00, 0x00, 0x79, 0x00, 0x00, 0x00,
  0x7a, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00, 0x79, 0x00, 0x00, 0x00,
  0x41, 0x00, 0x05, 0x00, 0x48, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00,
  0x5c, 0x00, 0x00, 0x00, 0x7b, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x3f, 0x00, 0x00, 0x00, 0x7d, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00,
  0xb3, 0x00, 0x05, 0x00, 0x14, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00,
  0x6a, 0x00, 0x00, 0x00, 0x7d, 0x00, 0x00, 0x00, 0xf9, 0x00, 0x02, 0x00,
  0x7a, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00, 0x7a, 0x00, 0x00, 0x00,
  0xf5, 0x00, 0x07, 0x00, 0x14, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00,
  0x78, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00,
  0x79, 0x00, 0x00, 0x00, 0xf7, 0x00, 0x03, 0x00, 0x81, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfa, 0x00, 0x04, 0x00, 0x7f, 0x00, 0x00, 0x00,
  0x80, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00,
  0x80, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00, 0x48, 0x00, 0x00, 0x00,
  0x82, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00, 0x7b, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00,
  0x82, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x04, 0x00, 0x37, 0x00, 0x00, 0x00,
  0x84, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x41, 0x00, 0x05, 0x00,
  0x74, 0x00, 0x00, 0x00, 0x85, 0x00, 0x00, 0x00, 0x3a, 0x00, 0x00, 0x00,
  0x7b, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x37, 0x00, 0x00, 0x00,
  0x86, 0x00, 0x00, 0x00, 0x85, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x05, 0x00,
  0x14, 0x00, 0x00, 0x00, 0x87, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00,
  0x86, 0x00, 0x00, 0x00, 0xf9, 0x00, 0x02, 0x00, 0x81, 0x00, 0x00, 0x00,
  0xf8, 0x00, 0x02, 0x00, 0x81, 0x00, 0x00, 0x00, 0xf5, 0x00, 0x07, 0x00,
  0x14, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00,
  0x7a, 0x00, 0x00, 0x00, 0x87, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
  0xf7, 0x00, 0x03, 0x00, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xfa, 0x00, 0x04, 0x00, 0x88, 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00,
  0x8a, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00, 0x89, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x3b, 0x00, 0x00, 0x00, 0x8c, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x40, 0x00, 0x00, 0x00,
  0x8d, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00, 0x62, 0x00, 0x05, 0x00,
  0x43, 0x00, 0x00, 0x00, 0x8e, 0x00, 0x00, 0x00, 0x8c, 0x00, 0x00, 0x00,
  0x8d, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x8b, 0x00, 0x00, 0x00,
  0x8e, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x3f, 0x00, 0x00, 0x00,
  0x91, 0x00, 0x00, 0x00, 0x49, 0x00, 0x00, 0x00, 0x6f, 0x00, 0x04, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00,
  0x83, 0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00, 0x94, 0x00, 0x00, 0x00,
  0x92, 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x3f, 0x00, 0x00, 0x00, 0x95, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00,
  0x6f, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00,
  0x95, 0x00, 0x00, 0x00, 0x83, 0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x97, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00,
  0x50, 0x00, 0x05, 0x00, 0x98, 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00,
  0x94, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x06, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x9a, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x42, 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00,
  0x9b, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00,
  0x9c, 0x00, 0x00, 0x00, 0x9a, 0x00, 0x00, 0x00, 0x39, 0x00, 0x06, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x9d, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00,
  0x9b, 0x00, 0x00, 0x00, 0x9c, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00,
  0x8f, 0x00, 0x00, 0x00, 0x9d, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x9e, 0x00, 0x00, 0x00, 0x8f, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x43, 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00,
  0x8b, 0x00, 0x00, 0x00, 0x8e, 0x00, 0x05, 0x00, 0x43, 0x00, 0x00, 0x00,
  0xa0, 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0x9e, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x43, 0x00, 0x00, 0x00, 0xa1, 0x00, 0x00, 0x00,
  0x45, 0x00, 0x00, 0x00, 0x81, 0x00, 0x05, 0x00, 0x43, 0x00, 0x00, 0x00,
  0xa2, 0x00, 0x00, 0x00, 0xa1, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00,
  0x3e, 0x00, 0x03, 0x00, 0x45, 0x00, 0x00, 0x00, 0xa2, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0xa3, 0x00, 0x00, 0x00,
  0x8f, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00,
  0xa4, 0x00, 0x00, 0x00, 0x47, 0x00, 0x00, 0x00, 0x81, 0x00, 0x05, 0x00,
  0x06, 0x00, 0x00, 0x00, 0xa5, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x00,
  0xa3, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x47, 0x00, 0x00, 0x00,
  0xa5, 0x00, 0x00, 0x00, 0xf9, 0x00, 0x02, 0x00, 0x8a, 0x00, 0x00, 0x00,
  0xf8, 0x00, 0x02, 0x00, 0x8a, 0x00, 0x00, 0x00, 0xf9, 0x00, 0x02, 0x00,
  0x57, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00, 0x57, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x3f, 0x00, 0x00, 0x00, 0xa6, 0x00, 0x00, 0x00,
  0x53, 0x00, 0x00, 0x00, 0x80, 0x00, 0x05, 0x00, 0x3f, 0x00, 0x00, 0x00,
  0xa8, 0x00, 0x00, 0x00, 0xa6, 0x00, 0x00, 0x00, 0xa7, 0x00, 0x00, 0x00,
  0x3e, 0x00, 0x03, 0x00, 0x53, 0x00, 0x00, 0x00, 0xa8, 0x00, 0x00, 0x00,
  0xf9, 0x00, 0x02, 0x00, 0x54, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00,
  0x56, 0x00, 0x00, 0x00, 0xf9, 0x00, 0x02, 0x00, 0x4e, 0x00, 0x00, 0x00,
  0xf8, 0x00, 0x02, 0x00, 0x4e, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x3f, 0x00, 0x00, 0x00, 0xa9, 0x00, 0x00, 0x00, 0x49, 0x00, 0x00, 0x00,
  0x80, 0x00, 0x05, 0x00, 0x3f, 0x00, 0x00, 0x00, 0xaa, 0x00, 0x00, 0x00,
  0xa9, 0x00, 0x00, 0x00, 0xa7, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00,
  0x49, 0x00, 0x00, 0x00, 0xaa, 0x00, 0x00, 0x00, 0xf9, 0x00, 0x02, 0x00,
  0x4b, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00, 0x4d, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x43, 0x00, 0x00, 0x00, 0xac, 0x00, 0x00, 0x00,
  0x45, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00,
  0xad, 0x00, 0x00, 0x00, 0x47, 0x00, 0x00, 0x00, 0x50, 0x00, 0x07, 0x00,
  0x43, 0x00, 0x00, 0x00, 0xae, 0x00, 0x00, 0x00, 0xad, 0x00, 0x00, 0x00,
  0xad, 0x00, 0x00, 0x00, 0xad, 0x00, 0x00, 0x00, 0xad, 0x00, 0x00, 0x00,
  0x88, 0x00, 0x05, 0x00, 0x43, 0x00, 0x00, 0x00, 0xaf, 0x00, 0x00, 0x00,
  0xac, 0x00, 0x00, 0x00, 0xae, 0x00, 0x00, 0x00, 0x50, 0x00, 0x07, 0x00,
  0x43, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00,
  0x34, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00,
  0x50, 0x00, 0x07, 0x00, 0x43, 0x00, 0x00, 0x00, 0xb1, 0x00, 0x00, 0x00,
  0x18, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
  0x18, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x08, 0x00, 0x43, 0x00, 0x00, 0x00,
  0xb2, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x00, 0x00,
  0xaf, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 0xb1, 0x00, 0x00, 0x00,
  0x3e, 0x00, 0x03, 0x00, 0xab, 0x00, 0x00, 0x00, 0xb2, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x3b, 0x00, 0x00, 0x00, 0xb4, 0x00, 0x00, 0x00,
  0xb3, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x5e, 0x00, 0x00, 0x00,
  0xb5, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x4f, 0x00, 0x07, 0x00,
  0x38, 0x00, 0x00, 0x00, 0xb6, 0x00, 0x00, 0x00, 0xb5, 0x00, 0x00, 0x00,
  0xb5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x7c, 0x00, 0x04, 0x00, 0x40, 0x00, 0x00, 0x00, 0xb7, 0x00, 0x00, 0x00,
  0xb6, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x43, 0x00, 0x00, 0x00,
  0xb8, 0x00, 0x00, 0x00, 0xab, 0x00, 0x00, 0x00, 0x63, 0x00, 0x04, 0x00,
  0xb4, 0x00, 0x00, 0x00, 0xb7, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00,
  0xfd, 0x00, 0x01, 0x00, 0x38, 0x00, 0x01, 0x00, 0x36, 0x00, 0x05, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x37, 0x00, 0x03, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x09, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00, 0x0b, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x06, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x12, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
  0x11, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x05, 0x00, 0x14, 0x00, 0x00, 0x00,
  0x15, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
  0xf7, 0x00, 0x03, 0x00, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xfa, 0x00, 0x04, 0x00, 0x15, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00,
  0x1a, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00, 0x16, 0x00, 0x00, 0x00,
  0xfe, 0x00, 0x02, 0x00, 0x18, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00,
  0x1a, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x1c, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x85, 0x00, 0x05, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00,
  0x1c, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x06, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x1e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
  0x1d, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x1f, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x85, 0x00, 0x05, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00,
  0x1f, 0x00, 0x00, 0x00, 0x88, 0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x21, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
  0xfe, 0x00, 0x02, 0x00, 0x21, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00,
  0x17, 0x00, 0x00, 0x00, 0xff, 0x00, 0x01, 0x00, 0x38, 0x00, 0x01, 0x00,
  0x36, 0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x37, 0x00, 0x03, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x37, 0x00, 0x03, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00,
  0x10, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x29, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x3d, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00,
  0x0e, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x25, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0xbc, 0x00, 0x05, 0x00,
  0x14, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00,
  0x25, 0x00, 0x00, 0x00, 0xf7, 0x00, 0x03, 0x00, 0x28, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfa, 0x00, 0x04, 0x00, 0x26, 0x00, 0x00, 0x00,
  0x27, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00,
  0x27, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x2a, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00,
  0x29, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x39, 0x00, 0x05, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00,
  0x29, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x2c, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x2d, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
  0x88, 0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00,
  0x2c, 0x00, 0x00, 0x00, 0x2d, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00,
  0x2f, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x39, 0x00, 0x05, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00,
  0x2f, 0x00, 0x00, 0x00, 0x85, 0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00,
  0x31, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
  0xfe, 0x00, 0x02, 0x00, 0x31, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00,
  0x33, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x02, 0x00, 0x34, 0x00, 0x00, 0x00,
  0xf8, 0x00, 0x02, 0x00, 0x28, 0x00, 0x00, 0x00, 0xff, 0x00, 0x01, 0x00,
  0x38, 0x00, 0x01, 0x00
};
unsigned int _resample_comp_spv_len = 4204;

PFN_vkDestroyDebugUtilsMessengerEXT ImageGenerator::s_vkDestroyDebugUtilsMessenger = nullptr;
static VKAPI_ATTR VkBool32 VKAPI_CALL vk_debug_callback(VkDebugUtilsMessageSeverityFlagBitsEXT severity,
    VkDebugUtilsMessageTypeFlagsEXT type, const VkDebugUtilsMessengerCallbackDataEXT* cb_data, void* user_data)
{
    spdlog::level::level_enum which_level;
    if (severity >= VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT)
        which_level = spdlog::level::err;
    else if (severity >= VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT)
        which_level = spdlog::level::warn;
    else if (severity >= VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT && ((type & VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT) != 0))
        which_level = spdlog::level::info;
    else
        which_level = spdlog::level::debug;

    spdlog::log(which_level, "Vulkan {}", cb_data->pMessage);

#ifdef TWOGAME_DEBUG_BUILD
    if (which_level == spdlog::level::err)
        std::raise(SIGABRT);
#endif

    return VK_FALSE;
}

ImageGenerator::ImageGenerator()
{
    create_instance();
    create_debug_messenger();
    pick_physical_device();
    create_logical_device();
    create_pipeline();

#ifdef RENDERDOC_DEBUGGER
    if (void* mod = dlopen("/usr/lib/librenderdoc.so", RTLD_NOW)) {
        pRENDERDOC_GetAPI s = (pRENDERDOC_GetAPI)dlsym(mod, "RENDERDOC_GetAPI");
        int ret = s(eRENDERDOC_API_Version_1_1_2, &m_debugger);
        assert(ret == 1);
    } else {
        fprintf(stderr, "dlopen: %s\n", dlerror());
    }
#else
    m_debugger = nullptr;
#endif
}

ImageGenerator::~ImageGenerator()
{
    vkDestroyPipeline(m_device, m_pipeline, nullptr);
    vkDestroyPipelineLayout(m_device, m_pipeline_layout, nullptr);
    vkDestroyDescriptorSetLayout(m_device, m_descriptor_layout, nullptr);
    vkDestroyShaderModule(m_device, m_shader, nullptr);
    vkDestroyCommandPool(m_device, m_command_pool, nullptr);
    vkDestroyDevice(m_device, nullptr);
    if (m_debug_messenger)
        s_vkDestroyDebugUtilsMessenger(m_instance, m_debug_messenger, nullptr);
    vkDestroyInstance(m_instance, nullptr);
}

void ImageGenerator::create_instance()
{
    unsigned int n;
    std::vector<const char*> instance_extensions;
    if (ENABLE_VALIDATION_LAYERS)
        instance_extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);

    VkInstanceCreateFlags instance_create_flags = 0;
    std::vector<VkExtensionProperties> available_instance_extensions;
    VK_CHECK(vkEnumerateInstanceExtensionProperties(nullptr, &n, nullptr));
    available_instance_extensions.resize(n);
    VK_CHECK(vkEnumerateInstanceExtensionProperties(nullptr, &n, available_instance_extensions.data()));
    for (auto& ext : available_instance_extensions) {
        if (strcmp(VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME, ext.extensionName) == 0) {
            instance_extensions.push_back(VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME);
            instance_create_flags |= VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR;
        }
    }

    VkApplicationInfo appinfo {};
    appinfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
    appinfo.apiVersion = VK_API_VERSION_1_2;

    VkInstanceCreateInfo createinfo {};
    createinfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
    createinfo.flags = instance_create_flags;
    createinfo.pApplicationInfo = &appinfo;
    createinfo.enabledLayerCount = INSTANCE_LAYERS_COUNT;
    createinfo.ppEnabledLayerNames = INSTANCE_LAYERS;
    createinfo.enabledExtensionCount = instance_extensions.size();
    createinfo.ppEnabledExtensionNames = instance_extensions.data();
    VK_CHECK(vkCreateInstance(&createinfo, nullptr, &m_instance));
    volkLoadInstance(m_instance);
}

void ImageGenerator::create_debug_messenger()
{
    if (ENABLE_VALIDATION_LAYERS == false)
        return;

    auto vkCreateDebugUtilsMessenger = (PFN_vkCreateDebugUtilsMessengerEXT)vkGetInstanceProcAddr(m_instance, "vkCreateDebugUtilsMessengerEXT");
    if (s_vkDestroyDebugUtilsMessenger == nullptr)
        s_vkDestroyDebugUtilsMessenger = (PFN_vkDestroyDebugUtilsMessengerEXT)vkGetInstanceProcAddr(m_instance, "vkDestroyDebugUtilsMessengerEXT");
    if (vkCreateDebugUtilsMessenger == nullptr || s_vkDestroyDebugUtilsMessenger == nullptr) {
        spdlog::critical("vulkan extension " VK_EXT_DEBUG_UTILS_EXTENSION_NAME " not present");
        std::terminate();
    }

    VkDebugUtilsMessengerCreateInfoEXT createinfo {};
    createinfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
    createinfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
    createinfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
    createinfo.pfnUserCallback = vk_debug_callback;

    VK_CHECK(vkCreateDebugUtilsMessenger(m_instance, &createinfo, nullptr, &m_debug_messenger));
}

static bool evaluate_physical_device(VkPhysicalDevice hwd, const VkPhysicalDeviceProperties& device_props)
{
    uint32_t count;
    std::vector<VkExtensionProperties> available_exts;
    bool has_portability_subset = false;
    vkEnumerateDeviceExtensionProperties(hwd, nullptr, &count, nullptr);
    available_exts.resize(count);
    vkEnumerateDeviceExtensionProperties(hwd, nullptr, &count, available_exts.data());
    std::set<std::string> required_exts;
    for (const auto& ext : available_exts) {
        if (strcmp(VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME, ext.extensionName) == 0)
            has_portability_subset = true;
        auto it = required_exts.find(ext.extensionName);
        if (it != required_exts.end())
            required_exts.erase(it);
    }
    if (!required_exts.empty()) {
        for (const auto& missing_ext : required_exts)
            spdlog::debug("{}: skipping: missing required extension {}", device_props.deviceName, missing_ext.c_str());
        return false;
    }

    return true;
}

void ImageGenerator::pick_physical_device()
{
    uint32_t device_count = 0;
    std::vector<VkPhysicalDevice> devices;
    vkEnumeratePhysicalDevices(m_instance, &device_count, nullptr);
    devices.resize(device_count);
    vkEnumeratePhysicalDevices(m_instance, &device_count, devices.data());

    VkPhysicalDevice dGPU = VK_NULL_HANDLE, iGPU = VK_NULL_HANDLE;
    for (auto& device : devices) {
        VkPhysicalDeviceProperties device_props;
        vkGetPhysicalDeviceProperties(device, &device_props);
        if (evaluate_physical_device(device, device_props)) {
            m_hwd = device;
            if (device_props.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) {
                dGPU = device;
            } else if (device_props.deviceType == VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU) {
                iGPU = device;
            }
        }
    }

    // m_hwd is the last device that is barely usable; dGPU is the first discrete GPU; iGPU is the first integrated GPU.
    if (dGPU != VK_NULL_HANDLE)
        m_hwd = dGPU;
    else if (iGPU != VK_NULL_HANDLE)
        m_hwd = iGPU;
}

void ImageGenerator::create_logical_device()
{
    uint32_t count = 0;
    std::vector<VkExtensionProperties> available_exts;
    std::vector<const char*> extensions;
    if (m_hwd == VK_NULL_HANDLE) {
        spdlog::critical("no usable physical devices were found");
        std::terminate();
    }

    vkEnumerateDeviceExtensionProperties(m_hwd, nullptr, &count, nullptr);
    available_exts.resize(count);
    vkEnumerateDeviceExtensionProperties(m_hwd, nullptr, &count, available_exts.data());
    for (auto& ext : available_exts) {
        if (strcmp(VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME, ext.extensionName) == 0)
            extensions.push_back(VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME);
    }

    VkPhysicalDeviceProperties2 properties {};
    properties.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
    vkGetPhysicalDeviceProperties2(m_hwd, &properties);
    spdlog::info("selecting device {}", properties.properties.deviceName);
#ifdef TWOGAME_DEBUG_BUILD
    for (auto& e : extensions)
        spdlog::info("    with {}", e);
#endif

    std::vector<VkQueueFamilyProperties> qf_properties;
    vkGetPhysicalDeviceQueueFamilyProperties(m_hwd, &count, nullptr);
    qf_properties.resize(count);
    vkGetPhysicalDeviceQueueFamilyProperties(m_hwd, &count, qf_properties.data());

    uint32_t qf_primary = UINT32_MAX;
    for (uint32_t i = 0; i < count; i++) {
        if ((qf_properties[i].queueFlags & (VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT)) == (VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT)) {
            qf_primary = i;
            break;
        }
    }

    VkDeviceQueueCreateInfo qci {};
    float one = 1;
    qci.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
    qci.queueFamilyIndex = qf_primary;
    qci.queueCount = 1;
    qci.pQueuePriorities = &one;

    VkDeviceCreateInfo createinfo {};
    VkPhysicalDeviceFeatures features {};
    createinfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
    createinfo.pNext = nullptr;
    createinfo.queueCreateInfoCount = 1;
    createinfo.pQueueCreateInfos = &qci;
    createinfo.enabledExtensionCount = extensions.size();
    createinfo.ppEnabledExtensionNames = extensions.data();
    createinfo.pEnabledFeatures = &features;
    VK_CHECK(vkCreateDevice(m_hwd, &createinfo, nullptr, &m_device));
    volkLoadDevice(m_device);
    vkGetDeviceQueue(m_device, qf_primary, 0, &m_queue);

    VkCommandPoolCreateInfo cmdpool_ci = {};
    cmdpool_ci.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
    cmdpool_ci.queueFamilyIndex = qf_primary;
    cmdpool_ci.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
    VK_CHECK(vkCreateCommandPool(m_device, &cmdpool_ci, nullptr, &m_command_pool));
}

void ImageGenerator::create_pipeline()
{
    VkShaderModuleCreateInfo shader_ci {};
    shader_ci.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
    shader_ci.codeSize = _resample_comp_spv_len;
    shader_ci.pCode = reinterpret_cast<uint32_t*>(_resample_comp_spv);
    VK_CHECK(vkCreateShaderModule(m_device, &shader_ci, nullptr, &m_shader));

    VkDescriptorSetLayoutBinding bindings[] = {
        { 0, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 1, VK_SHADER_STAGE_COMPUTE_BIT, nullptr },
        { 1, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 1, VK_SHADER_STAGE_COMPUTE_BIT, nullptr }
    };
    VkDescriptorSetLayoutCreateInfo dlci {};
    dlci.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    dlci.bindingCount = 2;
    dlci.pBindings = bindings;
    VK_CHECK(vkCreateDescriptorSetLayout(m_device, &dlci, nullptr, &m_descriptor_layout));

    VkPipelineLayoutCreateInfo layout_ci {};
    layout_ci.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    layout_ci.setLayoutCount = 1;
    layout_ci.pSetLayouts = &m_descriptor_layout;
    VK_CHECK(vkCreatePipelineLayout(m_device, &layout_ci, nullptr, &m_pipeline_layout));

    VkComputePipelineCreateInfo createinfo {};
    createinfo.sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
    createinfo.stage.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    createinfo.stage.stage = VK_SHADER_STAGE_COMPUTE_BIT;
    createinfo.stage.module = m_shader;
    createinfo.stage.pName = "main";
    createinfo.layout = m_pipeline_layout;
    VK_CHECK(vkCreateComputePipelines(m_device, nullptr, 1, &createinfo, nullptr, &m_pipeline));
}

uint32_t ImageGenerator::find_memory_type(uint32_t type_filter, VkMemoryPropertyFlags flags)
{
    VkPhysicalDeviceMemoryProperties props;
    vkGetPhysicalDeviceMemoryProperties(m_hwd, &props);

    for (uint32_t i = 0; i < props.memoryTypeCount; i++) {
        if ((type_filter & (1 << i)) && (props.memoryTypes[i].propertyFlags & flags) == flags)
            return i;
    }
    assert(false);
}

static int stb_io_read(void* user, char* data, int size)
{
    std::ifstream* self = reinterpret_cast<std::ifstream*>(user);
    self->read(data, size);
    return self->gcount();
}

static void stb_io_skip(void* user, int n)
{
    std::ifstream* self = reinterpret_cast<std::ifstream*>(user);
    self->seekg(n, std::ios_base::cur);
}

static int stb_io_eof(void* user)
{
    std::ifstream* self = reinterpret_cast<std::ifstream*>(user);
    return self->eof();
}

void ImageGenerator::generate(const std::filesystem::path& out, const unsigned char* image_data, size_t image_len, std::string_view mimetype)
{
    int x, y, n;
    if (stbi_is_hdr_from_memory(image_data, image_len)) {
        float* rd = stbi_loadf_from_memory(image_data, image_len, &x, &y, &n, 4);
        if (rd)
            return generate(out, rd, x, y, VK_FORMAT_R32G32B32A32_SFLOAT);
        else
            spdlog::error("failed to decode: {}", stbi_failure_reason());
    } else if (stbi_is_16_bit_from_memory(image_data, image_len)) {
        stbi_us* rd = stbi_load_16_from_memory(image_data, image_len, &x, &y, &n, 4);
        if (rd)
            return generate(out, rd, x, y, VK_FORMAT_R16G16B16A16_UINT);
        else
            spdlog::error("failed to decode: {}", stbi_failure_reason());
    } else {
        stbi_uc* rd = stbi_load_from_memory(image_data, image_len, &x, &y, &n, 4);
        if (rd)
            return generate(out, rd, x, y, VK_FORMAT_R8G8B8A8_SRGB);
        else
            spdlog::error("failed to decode: {}", stbi_failure_reason());
    }
}

void ImageGenerator::generate(const std::filesystem::path& out, const std::filesystem::path& in)
{
    stbi_io_callbacks iocb {};
    iocb.read = stb_io_read;
    iocb.skip = stb_io_skip;
    iocb.eof = stb_io_eof;

    std::ifstream reader(in);
    int x, y, n;
    if (stbi_is_hdr_from_callbacks(&iocb, &reader)) {
        reader.seekg(0);
        float* rd = stbi_loadf_from_callbacks(&iocb, &reader, &x, &y, &n, 4);
        if (rd)
            return generate(out, rd, x, y, VK_FORMAT_R32G32B32A32_SFLOAT);
        else
            spdlog::error("failed to decode {}: {}", in.c_str(), stbi_failure_reason());
    } else if (stbi_is_16_bit_from_callbacks(&iocb, &reader)) {
        reader.seekg(0);
        stbi_us* rd = stbi_load_16_from_callbacks(&iocb, &reader, &x, &y, &n, 4);
        if (rd)
            return generate(out, rd, x, y, VK_FORMAT_R16G16B16A16_UINT);
        else
            spdlog::error("failed to decode {}: {}", in.c_str(), stbi_failure_reason());
    } else {
        reader.seekg(0);
        stbi_uc* rd = stbi_load_from_callbacks(&iocb, &reader, &x, &y, &n, 4);
        if (rd)
            return generate(out, rd, x, y, VK_FORMAT_R8G8B8A8_SRGB);
        else
            spdlog::error("failed to decode {}: {}", in.c_str(), stbi_failure_reason());
    }
}

static int format_size(VkFormat fmt)
{
    switch (fmt) {
    case VK_FORMAT_R32G32B32A32_SFLOAT:
        return 16;
    case VK_FORMAT_R16G16B16A16_UINT:
        return 8;
    case VK_FORMAT_R8G8B8A8_SRGB:
        return 4;
    default:
        assert(false);
    }
}

void ImageGenerator::generate(const std::filesystem::path& out, void* raw_image_data, int w, int h, VkFormat input_format)
{
    size_t mip_count = 1 + floor(log2(std::max(w, h)));
    VkDescriptorPool descriptor_pool;
    VkDescriptorPoolSize descriptor_pool_sizes[] = {
        { VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, static_cast<uint32_t>(mip_count * 4) }
    };
    VkDescriptorPoolCreateInfo descriptor_pool_ci {};
    descriptor_pool_ci.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
    descriptor_pool_ci.maxSets = mip_count * 2;
    descriptor_pool_ci.poolSizeCount = 1;
    descriptor_pool_ci.pPoolSizes = descriptor_pool_sizes;
    VK_CHECK(vkCreateDescriptorPool(m_device, &descriptor_pool_ci, nullptr, &descriptor_pool));

    VkBuffer staging_buffer;
    VkDeviceMemory staging_buffer_mem;
    VkBufferCreateInfo buffer_ci {};
    buffer_ci.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    buffer_ci.size = w * h * format_size(input_format) * 2;
    buffer_ci.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
    VK_CHECK(vkCreateBuffer(m_device, &buffer_ci, nullptr, &staging_buffer));

    VkImage staging_image, storage_image, output_image;
    VkDeviceMemory staging_image_mem, storage_image_mem, output_image_mem;
    VkImageCreateInfo image_ci {};
    image_ci.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
    image_ci.imageType = VK_IMAGE_TYPE_2D;
    image_ci.format = input_format;
    image_ci.extent.width = w;
    image_ci.extent.height = h;
    image_ci.extent.depth = 1;
    image_ci.mipLevels = 1;
    image_ci.arrayLayers = 1;
    image_ci.samples = VK_SAMPLE_COUNT_1_BIT;
    image_ci.tiling = VK_IMAGE_TILING_OPTIMAL;
    image_ci.usage = VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT;
    VK_CHECK(vkCreateImage(m_device, &image_ci, nullptr, &staging_image));
    image_ci.mipLevels = mip_count;
    VK_CHECK(vkCreateImage(m_device, &image_ci, nullptr, &output_image));
    image_ci.format = VK_FORMAT_R32G32B32A32_SFLOAT;
    image_ci.usage = VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_STORAGE_BIT;
    VK_CHECK(vkCreateImage(m_device, &image_ci, nullptr, &storage_image));

    VkMemoryAllocateInfo alloc_info {};
    VkMemoryRequirements mem_requirements;
    vkGetBufferMemoryRequirements(m_device, staging_buffer, &mem_requirements);
    alloc_info.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    alloc_info.allocationSize = mem_requirements.size;
    alloc_info.memoryTypeIndex = find_memory_type(mem_requirements.memoryTypeBits, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);
    VK_CHECK(vkAllocateMemory(m_device, &alloc_info, nullptr, &staging_buffer_mem));
    VK_CHECK(vkBindBufferMemory(m_device, staging_buffer, staging_buffer_mem, 0));
    vkGetImageMemoryRequirements(m_device, staging_image, &mem_requirements);
    alloc_info.allocationSize = mem_requirements.size;
    alloc_info.memoryTypeIndex = find_memory_type(mem_requirements.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);
    VK_CHECK(vkAllocateMemory(m_device, &alloc_info, nullptr, &staging_image_mem));
    VK_CHECK(vkBindImageMemory(m_device, staging_image, staging_image_mem, 0));
    vkGetImageMemoryRequirements(m_device, storage_image, &mem_requirements);
    alloc_info.allocationSize = mem_requirements.size;
    alloc_info.memoryTypeIndex = find_memory_type(mem_requirements.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);
    VK_CHECK(vkAllocateMemory(m_device, &alloc_info, nullptr, &storage_image_mem));
    VK_CHECK(vkBindImageMemory(m_device, storage_image, storage_image_mem, 0));
    vkGetImageMemoryRequirements(m_device, output_image, &mem_requirements);
    alloc_info.allocationSize = mem_requirements.size;
    alloc_info.memoryTypeIndex = find_memory_type(mem_requirements.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);
    VK_CHECK(vkAllocateMemory(m_device, &alloc_info, nullptr, &output_image_mem));
    VK_CHECK(vkBindImageMemory(m_device, output_image, output_image_mem, 0));

    std::vector<VkImageView> image_views(mip_count);
    VkImageViewCreateInfo image_view_ci {};
    image_view_ci.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
    image_view_ci.image = storage_image;
    image_view_ci.viewType = VK_IMAGE_VIEW_TYPE_2D;
    image_view_ci.format = image_ci.format;
    image_view_ci.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    image_view_ci.subresourceRange.levelCount = 1;
    image_view_ci.subresourceRange.baseArrayLayer = 0;
    image_view_ci.subresourceRange.layerCount = 1;
    for (size_t i = 0; i < mip_count; i++) {
        image_view_ci.subresourceRange.baseMipLevel = i;
        VK_CHECK(vkCreateImageView(m_device, &image_view_ci, nullptr, &image_views[i]));
    }

    void* sbdata;
    VK_CHECK(vkMapMemory(m_device, staging_buffer_mem, 0, VK_WHOLE_SIZE, 0, &sbdata));
    memcpy(sbdata, raw_image_data, w * h * format_size(input_format));
    vkUnmapMemory(m_device, staging_buffer_mem);
    STBI_FREE(raw_image_data);

    VkCommandBuffer cmd;
    VkCommandBufferAllocateInfo cb_info {};
    cb_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    cb_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    cb_info.commandPool = m_command_pool;
    cb_info.commandBufferCount = 1;
    VK_CHECK(vkAllocateCommandBuffers(m_device, &cb_info, &cmd));

    std::vector<VkDescriptorSet> descriptor_sets(mip_count - 1);
    std::vector<VkDescriptorSetLayout> descriptor_alloc_layouts(descriptor_sets.size());
    std::vector<VkWriteDescriptorSet> descriptor_writes(descriptor_sets.size() * 2);
    std::vector<VkDescriptorImageInfo> descriptor_images(descriptor_sets.size() * 2);
    VkDescriptorSetAllocateInfo descriptor_alloc_info {};
    descriptor_alloc_info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
    descriptor_alloc_info.descriptorPool = descriptor_pool;
    descriptor_alloc_info.descriptorSetCount = descriptor_sets.size();
    descriptor_alloc_info.pSetLayouts = descriptor_alloc_layouts.data();
    std::fill(descriptor_alloc_layouts.begin(), descriptor_alloc_layouts.end(), m_descriptor_layout);
    vkAllocateDescriptorSets(m_device, &descriptor_alloc_info, descriptor_sets.data());

#ifdef RENDERDOC_DEBUGGER
    if (m_debugger)
        reinterpret_cast<RENDERDOC_API_1_1_2*>(m_debugger)->StartFrameCapture(nullptr, nullptr);
#endif

    for (size_t i = 0; i < descriptor_writes.size(); i++) {
        descriptor_writes[i].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
        descriptor_writes[i].pNext = nullptr;
        descriptor_writes[i].dstSet = descriptor_sets[i / 2];
        descriptor_writes[i].dstBinding = i % 2;
        descriptor_writes[i].descriptorCount = 1;
        descriptor_writes[i].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
        descriptor_writes[i].pImageInfo = &descriptor_images[i];
        descriptor_images[i].sampler = VK_NULL_HANDLE;
        descriptor_images[i].imageView = image_views[(i + 1) / 2];
        descriptor_images[i].imageLayout = VK_IMAGE_LAYOUT_GENERAL;
    }
    vkUpdateDescriptorSets(m_device, descriptor_writes.size(), descriptor_writes.data(), 0, nullptr);

    VkCommandBufferBeginInfo begin_info {};
    begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    begin_info.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
    vkBeginCommandBuffer(cmd, &begin_info);

    VkImageMemoryBarrier barrier {};
    barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
    barrier.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    barrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    barrier.image = staging_image;
    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    barrier.subresourceRange.baseMipLevel = 0;
    barrier.subresourceRange.levelCount = VK_REMAINING_MIP_LEVELS;
    barrier.subresourceRange.baseArrayLayer = 0;
    barrier.subresourceRange.layerCount = 1;
    barrier.srcAccessMask = 0;
    barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
    vkCmdPipelineBarrier(cmd, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, 0, 0, nullptr, 0, nullptr, 1, &barrier);
    barrier.image = storage_image;
    vkCmdPipelineBarrier(cmd, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, 0, 0, nullptr, 0, nullptr, 1, &barrier);
    barrier.image = output_image;
    vkCmdPipelineBarrier(cmd, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, 0, 0, nullptr, 0, nullptr, 1, &barrier);
    // Ensure that for {barrier.image}, image layouts are changed, and
    // {0} operations during {VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT} is all done
    // before any {VK_ACCESS_TRANSFER_WRITE_BIT} operations during {VK_PIPELINE_STAGE_TRANSFER_BIT}

    VkBufferImageCopy bcopy {};
    bcopy.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    bcopy.imageSubresource.mipLevel = 0;
    bcopy.imageSubresource.baseArrayLayer = 0;
    bcopy.imageSubresource.layerCount = 1;
    bcopy.imageExtent = image_ci.extent;
    vkCmdCopyBufferToImage(cmd, staging_buffer, staging_image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &bcopy);

    barrier.image = staging_image;
    barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
    barrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
    barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
    barrier.dstAccessMask = 0;
    vkCmdPipelineBarrier(cmd, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, 0, 0, nullptr, 0, nullptr, 1, &barrier);

    VkImageBlit region {};
    region.srcOffsets[1].x = region.dstOffsets[1].x = w;
    region.srcOffsets[1].y = region.dstOffsets[1].y = h;
    region.srcOffsets[1].z = region.dstOffsets[1].z = 1;
    region.srcSubresource.aspectMask = region.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    region.srcSubresource.mipLevel = region.dstSubresource.mipLevel = 0;
    region.srcSubresource.baseArrayLayer = region.dstSubresource.baseArrayLayer = 0;
    region.srcSubresource.layerCount = region.dstSubresource.layerCount = 1;
    vkCmdBlitImage(cmd, staging_image, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, storage_image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &region, VK_FILTER_NEAREST);

    barrier.image = storage_image;
    barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
    barrier.newLayout = VK_IMAGE_LAYOUT_GENERAL;
    barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
    barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_SHADER_WRITE_BIT;
    vkCmdPipelineBarrier(cmd, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, 0, 0, nullptr, 0, nullptr, 1, &barrier);
    vkCmdBindPipeline(cmd, VK_PIPELINE_BIND_POINT_COMPUTE, m_pipeline);

    size_t mip_width = w / 2, mip_height = h / 2;
    for (size_t i = 1; i < mip_count; i++) {
        if (i != 1) {
            barrier.oldLayout = barrier.newLayout = VK_IMAGE_LAYOUT_GENERAL;
            barrier.subresourceRange.baseMipLevel = 0;
            barrier.subresourceRange.levelCount = i;
            barrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
            barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
            vkCmdPipelineBarrier(cmd, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, 0, 0, nullptr, 0, nullptr, 1, &barrier);
        }

        vkCmdBindDescriptorSets(cmd, VK_PIPELINE_BIND_POINT_COMPUTE, m_pipeline_layout, 0, 1, &descriptor_sets[i - 1], 0, nullptr);
        vkCmdDispatch(cmd, (mip_width + 7) / 8, (mip_height + 7) / 8, 1);
        mip_width /= 2;
        mip_height /= 2;
    }

    barrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
    barrier.subresourceRange.levelCount = VK_REMAINING_MIP_LEVELS;
    barrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
    barrier.dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT;
    vkCmdPipelineBarrier(cmd, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, 0, 0, nullptr, 0, nullptr, 1, &barrier);

    std::vector<VkImageBlit> blitout(mip_count);
    for (size_t i = 0; i < mip_count; i++) {
        blitout[i].srcSubresource.aspectMask = blitout[i].dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        blitout[i].srcSubresource.mipLevel = blitout[i].dstSubresource.mipLevel = i;
        blitout[i].srcSubresource.baseArrayLayer = blitout[i].srcSubresource.baseArrayLayer = 0;
        blitout[i].srcSubresource.layerCount = blitout[i].dstSubresource.layerCount = 1;
        blitout[i].srcOffsets[1].x = blitout[i].dstOffsets[1].x = w >> i;
        blitout[i].srcOffsets[1].y = blitout[i].dstOffsets[1].y = h >> i;
        blitout[i].srcOffsets[1].z = blitout[i].dstOffsets[1].z = 1;
    }
    vkCmdBlitImage(cmd, storage_image, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, output_image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, blitout.size(), blitout.data(), VK_FILTER_NEAREST);

    barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
    barrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
    barrier.image = output_image;
    barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
    barrier.dstAccessMask = 0;
    vkCmdPipelineBarrier(cmd, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, 0, 0, nullptr, 0, nullptr, 1, &barrier);

    size_t current_mip_offset = 0;
    std::vector<VkBufferImageCopy> writeout(mip_count);
    for (size_t i = 0; i < mip_count; i++) {
        writeout[i].bufferOffset = current_mip_offset;
        writeout[i].imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        writeout[i].imageSubresource.mipLevel = i;
        writeout[i].imageSubresource.baseArrayLayer = 0;
        writeout[i].imageSubresource.layerCount = 1;
        writeout[i].bufferRowLength = writeout[i].bufferImageHeight = 0;
        writeout[i].imageExtent.width = w >> i;
        writeout[i].imageExtent.height = h >> i;
        writeout[i].imageExtent.depth = 1;
        current_mip_offset += (w >> i) * (h >> i) * format_size(input_format);
    }
    vkCmdCopyImageToBuffer(cmd, output_image, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, staging_buffer, writeout.size(), writeout.data());
    vkEndCommandBuffer(cmd);

    VkSubmitInfo submit {};
    submit.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    submit.commandBufferCount = 1;
    submit.pCommandBuffers = &cmd;
    vkQueueSubmit(m_queue, 1, &submit, VK_NULL_HANDLE);
    vkDeviceWaitIdle(m_device);

#ifdef RENDERDOC_DEBUGGER
    if (m_debugger)
        reinterpret_cast<RENDERDOC_API_1_1_2*>(m_debugger)->EndFrameCapture(nullptr, nullptr);
#endif

    ktxTexture2* out_handle;
    ktxTextureCreateInfo ktx_ci {};
    ktx_ci.vkFormat = input_format;
    ktx_ci.baseWidth = w;
    ktx_ci.baseHeight = h;
    ktx_ci.baseDepth = 1;
    ktx_ci.numDimensions = 2;
    ktx_ci.numLevels = mip_count;
    ktx_ci.numLayers = ktx_ci.numFaces = 1;
    assert(ktxTexture2_Create(&ktx_ci, KTX_TEXTURE_CREATE_ALLOC_STORAGE, &out_handle) == KTX_SUCCESS);

    VK_CHECK(vkMapMemory(m_device, staging_buffer_mem, 0, VK_WHOLE_SIZE, 0, &sbdata));
    for (size_t i = 0; i < mip_count; i++) {
        assert(ktxTexture_SetImageFromMemory(ktxTexture(out_handle), i, 0, 0,
                   reinterpret_cast<const uint8_t*>(sbdata) + writeout[i].bufferOffset,
                   (w >> i) * (h >> i) * format_size(input_format))
            == KTX_SUCCESS);
    }
    vkUnmapMemory(m_device, staging_buffer_mem);

    if (input_format == VK_FORMAT_R8G8B8A8_SRGB && m_enable_uastc) {
        ktxBasisParams basis{};
        basis.structSize = sizeof(ktxBasisParams);
        basis.uastc = KTX_TRUE;
        assert(ktxTexture2_CompressBasisEx(out_handle, &basis));
    }
    assert(ktxTexture2_DeflateZstd(out_handle, 4) == KTX_SUCCESS);

    ktx_size_t out_size;
    ktx_uint8_t* out_buffer;
    ktxTexture_WriteToMemory(ktxTexture(out_handle), &out_buffer, &out_size);

    std::ofstream ofs(out);
    ofs.write(reinterpret_cast<char*>(out_buffer), out_size);
    free(out_buffer);
    ktxTexture_Destroy(ktxTexture(out_handle));

    for (auto it = image_views.begin(); it != image_views.end(); ++it)
        vkDestroyImageView(m_device, *it, nullptr);
    vkDestroyImage(m_device, staging_image, nullptr);
    vkDestroyImage(m_device, storage_image, nullptr);
    vkDestroyImage(m_device, output_image, nullptr);
    vkDestroyBuffer(m_device, staging_buffer, nullptr);
    vkFreeMemory(m_device, staging_buffer_mem, nullptr);
    vkFreeMemory(m_device, staging_image_mem, nullptr);
    vkFreeMemory(m_device, storage_image_mem, nullptr);
    vkFreeMemory(m_device, output_image_mem, nullptr);
    vkDestroyDescriptorPool(m_device, descriptor_pool, nullptr);
}
